<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<h2 id="headline">Headline</h2>
<blockquote>
<p>大事件后台 API 项目，API 接口文档请参考 <a href="https://www.showdoc.cc/escook?page_id=3707158761215217">https://www.showdoc.cc/escook?page_id=3707158761215217</a></p>
</blockquote>
<h2 id="1-">1. 初始化</h2>
<h3 id="1-1-">1.1 创建项目</h3>
<ol>
<li>新建 <code>api_server</code> 文件夹作为项目根目录，并在项目根目录中运行如下的命令，初始化包管理配置文件：</li>
</ol>
<pre><code class="lang-bash">npm init -y
</code></pre>
<ol start="2">
<li>运行如下的命令，安装特定版本的 <code>express</code>：</li>
</ol>
<pre><code class="lang-bash">npm i express@4.17.1
</code></pre>
<ol start="3">
<li>在项目根目录中新建 <code>app.js</code> 作为整个项目的入口文件，并初始化如下的代码：</li>
</ol>
<pre><code class="lang-js">// 导入 express 模块
const express = require(&#39;express&#39;)
// 创建 express 的服务器实例
const app = express()

// write your code here...

// 调用 app.listen 方法，指定端口号并启动web服务器
app.listen(3007, function () {
  console.log(&#39;api server running at http://127.0.0.1:3007&#39;)
})
</code></pre>
<h3 id="1-2-cors-">1.2 配置 cors 跨域</h3>
<ol>
<li>运行如下的命令，安装 <code>cors</code> 中间件：</li>
</ol>
<pre><code class="lang-bash">npm i cors@2.8.5
</code></pre>
<ol start="2">
<li>在 <code>app.js</code> 中导入并配置 <code>cors</code> 中间件：</li>
</ol>
<pre><code class="lang-js">// 导入 cors 中间件
const cors = require(&#39;cors&#39;)
// 将 cors 注册为全局中间件
app.use(cors())
</code></pre>
<h3 id="1-3-">1.3 配置解析表单数据的中间件</h3>
<ol>
<li>通过如下的代码，配置解析 <code>application/x-www-form-urlencoded</code> 格式的表单数据的中间件：</li>
</ol>
<pre><code class="lang-js">app.use(express.urlencoded({ extended: false }))
</code></pre>
<h3 id="1-4-">1.4 初始化路由相关的文件夹</h3>
<ol>
<li>在项目根目录中，新建 <code>router</code> 文件夹，用来存放所有的<code>路由</code>模块<blockquote>
<p>路由模块中，只存放客户端的请求与处理函数之间的映射关系</p>
</blockquote>
</li>
<li>在项目根目录中，新建 <code>router_handler</code> 文件夹，用来存放所有的 <code>路由处理函数模块</code><blockquote>
<p>路由处理函数模块中，专门负责存放每个路由对应的处理函数</p>
</blockquote>
</li>
</ol>
<h3 id="1-5-">1.5 初始化用户路由模块</h3>
<ol>
<li>在 <code>router</code> 文件夹中，新建 <code>user.js</code> 文件，作为用户的路由模块，并初始化代码如下：</li>
</ol>
<pre><code class="lang-js">const express = require(&#39;express&#39;)
// 创建路由对象
const router = express.Router()

// 注册新用户
router.post(&#39;/reguser&#39;, (req, res) =&gt; {
  res.send(&#39;reguser OK&#39;)
})

// 登录
router.post(&#39;/login&#39;, (req, res) =&gt; {
  res.send(&#39;login OK&#39;)
})

// 将路由对象共享出去
module.exports = router
</code></pre>
<ol start="2">
<li>在 <code>app.js</code> 中，导入并使用 <code>用户路由模块</code> ：</li>
</ol>
<pre><code class="lang-js">// 导入并注册用户路由模块
const userRouter = require(&#39;./router/user&#39;)
app.use(&#39;/api&#39;, userRouter)
</code></pre>
<h3 id="1-6-">1.6 抽离用户路由模块中的处理函数</h3>
<blockquote>
<p>目的：为了保证 <code>路由模块</code> 的纯粹性，所有的 <code>路由处理函数</code>，必须抽离到对应的 <code>路由处理函数模块</code> 中</p>
</blockquote>
<ol>
<li>在 <code>/router_handler/user.js</code> 中，使用 <code>exports</code> 对象，分别向外共享如下两个 <code>路由处理函数</code> ：</li>
</ol>
<pre><code class="lang-js">/**
 * 在这里定义和用户相关的路由处理函数，供 /router/user.js 模块进行调用
 */

// 注册用户的处理函数
exports.regUser = (req, res) =&gt; {
  res.send(&#39;reguser OK&#39;)
}

// 登录的处理函数
exports.login = (req, res) =&gt; {
  res.send(&#39;login OK&#39;)
}
</code></pre>
<ol start="2">
<li>将 <code>/router/user.js</code> 中的代码修改为如下结构：</li>
</ol>
<pre><code class="lang-js">const express = require(&#39;express&#39;)
const router = express.Router()

// 导入用户路由处理函数模块
const userHandler = require(&#39;../router_handler/user&#39;)

// 注册新用户
router.post(&#39;/reguser&#39;, userHandler.regUser)
// 登录
router.post(&#39;/login&#39;, userHandler.login)

module.exports = router
</code></pre>
<h2 id="2-">2. 登录注册</h2>
<h3 id="2-1-ev_users-">2.1 新建 ev_users 表</h3>
<ol>
<li>在 <code>my_db_01</code> 数据库中，新建 <code>ev_users</code> 表如下：
<img src="./images/1.jpg" alt="ev_users表结构"></li>
</ol>
<h3 id="2-2-mysql-">2.2 安装并配置 mysql 模块</h3>
<blockquote>
<p>在 API 接口项目中，需要安装并配置 <code>mysql</code> 这个第三方模块，来连接和操作 MySQL 数据库</p>
</blockquote>
<ol>
<li>运行如下命令，安装 <code>mysql</code> 模块：</li>
</ol>
<pre><code class="lang-bash">npm i mysql@2.18.1
</code></pre>
<ol start="2">
<li>在项目根目录中新建 <code>/db/index.js</code> 文件，在此自定义模块中创建数据库的连接对象：</li>
</ol>
<pre><code class="lang-js">// 导入 mysql 模块
const mysql = require(&#39;mysql&#39;)

// 创建数据库连接对象
const db = mysql.createPool({
  host: &#39;127.0.0.1&#39;,
  user: &#39;root&#39;,
  password: &#39;admin123&#39;,
  database: &#39;my_db_01&#39;,
})

// 向外共享 db 数据库连接对象
module.exports = db
</code></pre>
<h3 id="2-3-">2.3 注册</h3>
<h4 id="2-3-0-">2.3.0 实现步骤</h4>
<ol>
<li>检测表单数据是否合法</li>
<li>检测用户名是否被占用</li>
<li>对密码进行加密处理</li>
<li>插入新用户</li>
</ol>
<h4 id="2-3-1-">2.3.1 检测表单数据是否合法</h4>
<ol>
<li>判断用户名和密码是否为空</li>
</ol>
<pre><code class="lang-js">// 接收表单数据
const userinfo = req.body
// 判断数据是否合法
if (!userinfo.username || !userinfo.password) {
  return res.send({ status: 1, message: &#39;用户名或密码不能为空！&#39; })
}
</code></pre>
<h4 id="2-3-2-">2.3.2 检测用户名是否被占用</h4>
<ol>
<li>导入数据库操作模块：</li>
</ol>
<pre><code class="lang-js">const db = require(&#39;../db/index&#39;)
</code></pre>
<ol start="2">
<li>定义 SQL 语句：</li>
</ol>
<pre><code class="lang-js">const sql = `select * from ev_users where username=?`
</code></pre>
<ol start="3">
<li>执行 SQL 语句并根据结果判断用户名是否被占用：</li>
</ol>
<pre><code class="lang-js">db.query(sql, [userinfo.username], function (err, results) {
  // 执行 SQL 语句失败
  if (err) {
    return res.send({ status: 1, message: err.message })
  }
  // 用户名被占用
  if (results.length &gt; 0) {
    return res.send({ status: 1, message: &#39;用户名被占用，请更换其他用户名！&#39; })
  }
  // TODO: 用户名可用，继续后续流程...
})
</code></pre>
<h4 id="2-3-3-">2.3.3 对密码进行加密处理</h4>
<blockquote>
<p>为了保证密码的安全性，不建议在数据库以 <code>明文</code> 的形式保存用户密码，推荐对密码进行 <code>加密存储</code></p>
</blockquote>
<hr>
<p>在当前项目中，使用 <code>bcryptjs</code> 对用户密码进行加密，优点：</p>
<ul>
<li>加密之后的密码，<strong>无法被逆向破解</strong></li>
<li>同一明文密码多次加密，得到的<strong>加密结果各不相同</strong>，保证了安全性</li>
</ul>
<hr>
<ol>
<li>运行如下命令，安装指定版本的 <code>bcryptjs</code> ：</li>
</ol>
<pre><code class="lang-bash">npm i bcryptjs@2.4.3
</code></pre>
<ol start="2">
<li>在 <code>/router_handler/user.js</code> 中，导入 <code>bcryptjs</code> ：</li>
</ol>
<pre><code class="lang-js">const bcrypt = require(&#39;bcryptjs&#39;)
</code></pre>
<ol start="3">
<li>在注册用户的处理函数中，确认用户名可用之后，调用 <code>bcrypt.hashSync(明文密码, 随机盐的长度)</code> 方法，对用户的密码进行加密处理：</li>
</ol>
<pre><code class="lang-js">// 对用户的密码,进行 bcrype 加密，返回值是加密之后的密码字符串
userinfo.password = bcrypt.hashSync(userinfo.password, 10)
</code></pre>
<h4 id="2-3-4-">2.3.4 插入新用户</h4>
<ol>
<li>定义插入用户的 SQL 语句：</li>
</ol>
<pre><code class="lang-js">const sql = &#39;insert into ev_users set ?&#39;
</code></pre>
<ol start="2">
<li>调用 <code>db.query()</code> 执行 SQL 语句，插入新用户：</li>
</ol>
<pre><code class="lang-js">db.query(sql, { username: userinfo.username, password: userinfo.password }, function (err, results) {
  // 执行 SQL 语句失败
  if (err) return res.send({ status: 1, message: err.message })
  // SQL 语句执行成功，但影响行数不为 1
  if (results.affectedRows !== 1) {
    return res.send({ status: 1, message: &#39;注册用户失败，请稍后再试！&#39; })
  }
  // 注册成功
  res.send({ status: 0, message: &#39;注册成功！&#39; })
})
</code></pre>
<h3 id="2-4-res-send-">2.4 优化 res.send() 代码</h3>
<blockquote>
<p>在处理函数中，需要多次调用 <code>res.send()</code> 向客户端响应 <code>处理失败</code> 的结果，为了简化代码，可以手动封装一个 res.cc() 函数</p>
</blockquote>
<ol>
<li>在 <code>app.js</code> 中，所有路由之前，声明一个全局中间件，为 res 对象挂载一个 <code>res.cc()</code> 函数 ：</li>
</ol>
<pre><code class="lang-js">// 响应数据的中间件
app.use(function (req, res, next) {
  // status = 0 为成功； status = 1 为失败； 默认将 status 的值设置为 1，方便处理失败的情况
  res.cc = function (err, status = 1) {
    res.send({
      // 状态
      status,
      // 状态描述，判断 err 是 错误对象 还是 字符串
      message: err instanceof Error ? err.message : err,
    })
  }
  next()
})
</code></pre>
<h3 id="2-5-">2.5 优化表单数据验证</h3>
<blockquote>
<p>表单验证的原则：前端验证为辅，后端验证为主，后端<strong>永远不要相信</strong>前端提交过来的<strong>任何内容</strong></p>
</blockquote>
<p>在实际开发中，前后端都需要对表单的数据进行合法性的验证，而且，<strong>后端做为数据合法性验证的最后一个关口</strong>，在拦截非法数据方面，起到了至关重要的作用。</p>
<p>单纯的使用 <code>if...else...</code> 的形式对数据合法性进行验证，效率低下、出错率高、维护性差。因此，推荐使用<strong>第三方数据验证模块</strong>，来降低出错率、提高验证的效率与可维护性，<strong>让后端程序员把更多的精力放在核心业务逻辑的处理上</strong>。</p>
<ol>
<li>安装 <code>@escook/express-joi</code> 中间件，来实现自动对表单数据进行验证的功能：</li>
</ol>
<pre><code class="lang-bash">npm i @escook/express-joi
</code></pre>
<ol start="2">
<li>安装 <code>@hapi/joi</code> 包，为表单中携带的每个数据项，定义验证规则：</li>
</ol>
<pre><code class="lang-bash">npm install @hapi/joi@17.1.0
</code></pre>
<ol start="3">
<li>新建 <code>/schema/user.js</code> 用户信息验证规则模块，并初始化代码如下：</li>
</ol>
<pre><code class="lang-js">const joi = require(&#39;@hapi/joi&#39;)

/**
 * string() 值必须是字符串
 * alphanum() 值只能是包含 a-zA-Z0-9 的字符串
 * min(length) 最小长度
 * max(length) 最大长度
 * required() 值是必填项，不能为 undefined
 * pattern(正则表达式) 值必须符合正则表达式的规则
 */

// 用户名的验证规则
const username = joi.string().alphanum().min(1).max(10).required()
// 密码的验证规则
const password = joi.string().pattern(/^[\S]{6,12}$/).required()

// 注册和登录表单的验证规则对象
exports.reg_login_schema = {
  // 表示需要对 req.body 中的数据进行验证
  body: {
    username,
    password,
  },
}
</code></pre>
<ol start="4">
<li>修改 <code>/router/user.js</code> 中的代码如下：</li>
</ol>
<pre><code class="lang-js">const express = require(&#39;express&#39;)
const router = express.Router()

// 导入用户路由处理函数模块
const userHandler = require(&#39;../router_handler/user&#39;)

// 1. 导入验证表单数据的中间件
const expressJoi = require(&#39;@escook/express-joi&#39;)
// 2. 导入需要的验证规则对象
const { reg_login_schema } = require(&#39;../schema/user&#39;)

// 注册新用户
// 3. 在注册新用户的路由中，声明局部中间件，对当前请求中携带的数据进行验证
// 3.1 数据验证通过后，会把这次请求流转给后面的路由处理函数
// 3.2 数据验证失败后，终止后续代码的执行，并抛出一个全局的 Error 错误，进入全局错误级别中间件中进行处理
router.post(&#39;/reguser&#39;, expressJoi(reg_login_schema), userHandler.regUser)
// 登录
router.post(&#39;/login&#39;, userHandler.login)

module.exports = router
</code></pre>
<ol start="5">
<li>在 <code>app.js</code> 的全局错误级别中间件中，捕获验证失败的错误，并把验证失败的结果响应给客户端：</li>
</ol>
<pre><code class="lang-js">const joi = require(&#39;@hapi/joi&#39;)

// 错误中间件
app.use(function (err, req, res, next) {
  // 数据验证失败
  if (err instanceof joi.ValidationError) return res.cc(err)
  // 未知错误
  res.cc(err)
})
</code></pre>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>